//
//  main.swift
//  zone-metadata-generator
//
//  Created by jon on 6/9/22.
//

import Foundation
import CollectionConcurrencyKit
import kuluu_ffxi_emulator
import XMLCoder
import Stencil

struct Entity: Codable {
    var name: String
    var serverId: Int
    var targetIndex: Int
    var zoneId: Int
    
    enum CodingKeys: String, CodingKey {
        case name = "Name"
        case serverId = "ServerId"
        case targetIndex = "TargetIndex"
        case zoneId = "ZoneId"
    }
}

struct ArrayOfEntity: Codable {
    var entities: [Entity]
    
    enum CodingKeys: String, CodingKey {
        case entities = "Entity"
    }
}


enum ZoneMetadataType: String, Codable {
    case fishing = "Fishing area"
    case zoneLine = "ZoneLine"
    case doorOrObject = "Door or Object"
    case event = "Event"
    case elevator = "Elevators"
    case model = "Model"
}

struct ArrayOfSubRegion: Codable {
    var zoneMetadatas: [ZoneMetadata]
    
    enum CodingKeys: String, CodingKey {
        case zoneMetadatas = "SubRegion"
    }
}

struct ZoneMetadata: Codable, Identifiable {
    let fileId: Int
    let id: String
    
    let positionX: Float
    let positionY: Float
    let positionZ: Float
    
    lazy var simdPosition: SIMD3<Float> = {
        .init(x: positionX, y: positionY, z: positionZ)
    }()
    
    let rotationX: Float
    let rotationY: Float
    let rotationZ: Float
    
    lazy var simdRotation: SIMD3<Float> = {
        .init(x: rotationX, y: rotationY, z: rotationZ)
    }()
    
    let scaleX: Float
    let scaleY: Float
    let scaleZ: Float
    
    lazy var simdScale: SIMD3<Float> = {
        .init(x: scaleX, y: scaleY, z: scaleZ)
    }()
    
    let type: ZoneMetadataType?
    
    enum CodingKeys: String, CodingKey {
        case id = "Identifier"
        case fileId = "FileId"
        case positionX = "X"
        case positionY = "Y"
        case positionZ = "Z"
        case rotationX = "RotationX"
        case rotationY = "RotationY"
        case rotationZ = "RotationZ"
        case scaleX = "ScaleX"
        case scaleY = "ScaleY"
        case scaleZ = "ScaleZ"
        case type = "Type"
    }
}

let xmlDecoder: XMLDecoder = {
    let xmlDecoder = XMLDecoder()
    //    xmlDecoder.keyDecodingStrategy = .convertFromCapitalized
    //    xmlDecoder.shouldProcessNamespaces = false
    //    xmlDecoder.removeWhitespaceElements = false
    //    xmlDecoder.trimValueWhitespaces = false
    return xmlDecoder
}()

struct ZoneDescriptor {
    init(zoneInfo: ZoneInfo?, entity: [Entity]? = nil, zoneMetadatas: [ZoneMetadata]? = nil) {
        self.zoneInfo = zoneInfo
        self.entity = entity
        self.zoneMetadatas = zoneMetadatas
    }
    
    var zoneInfo: ZoneInfo!
    
    var entity: [Entity]!
    var zoneMetadatas: [ZoneMetadata]!
}

fileprivate let badChars = CharacterSet.alphanumerics.inverted

extension String {
    var uppercasingFirst: String {
        return prefix(1).uppercased() + dropFirst()
    }
    
    var lowercasingFirst: String {
        return prefix(1).lowercased() + dropFirst()
    }
    
    var camelized: String {
        guard !isEmpty else {
            return ""
        }
        
        let parts = self.components(separatedBy: badChars)
        
        let first = String(describing: parts.first!).lowercasingFirst
        let rest = parts.dropFirst().map({String($0).uppercasingFirst})
        
        return ([first] + rest).joined(separator: "")
    }
    
    var upperCamelized: String {
        guard !isEmpty else {
            return ""
        }
        
        let parts = self.components(separatedBy: badChars)
        
        let first = String(describing: parts.first!).uppercasingFirst
        let rest = parts.dropFirst().map({String($0).uppercasingFirst})
        
        return ([first] + rest).joined(separator: "")
    }
}

typealias ZoneDescriptorMap = [String: ZoneDescriptor]

@main
struct CLI {
    static func main() async throws {
        let zoneDescriptorMap = try await loadZoneDescriptorMap()
        let stencil = Stencil.Environment()
        let shortDate: String = {
            let df = DateFormatter()
            df.dateStyle = .short
            return df.string(from: .init())
        }()
        let template = """
        //
        //  {{ className }}.swift
        //
        //  Auto-generated by `zone-metadata-generator` on \(shortDate)
        //
        public struct {{ className }}: ZoneSceneMetadata {
            public let id = Zone.{{ instanceName }}.rawValue
            public let lines = [ZoneLine] = [{% for zl in zoneLines %}
                .init(
                    name: "{{ zl.id }}",
                    position: .init(x: {{ zl.positionX }}, y: {{ zl.positionY }}, z: {{ zl.positionZ }}),
                    rotation: .init(x: {{ zl.rotationX }}, y: {{ zl.rotationY }}, z: {{ zl.rotationZ }}),
                    scale: .init(x: {{ zl.scaleX }}, y: {{ zl.scaleY }}, z: {{ zl.scaleZ }})
                ),{% endfor %}
            ]
            public var fog: Fog?
            public var environment: ZoneEnvironment? {
                return .init(
                    skybox: nil,
                    atmosphere: nil
                )
            }
        }
        """
        try await zoneDescriptorMap.concurrentForEach { row in
            let (key, zone) = row
            let className = zone.zoneInfo.name.upperCamelized
            guard let classNameFirst = className.first, classNameFirst.isLetter || classNameFirst == "_" else { return print("skip") }
            let instanceName = zone.zoneInfo.name.camelized
            let zoneLines: [ZoneMetadata] = await zone.zoneMetadatas.concurrentCompactMap { $0.type == .zoneLine ? $0 : nil }
            let context: [String: Any] = [
                "id": key,
                "className": className,
                "instanceName": instanceName,
                "zoneLines": zoneLines
            ]
            let zoneCode = try stencil.renderTemplate(string: template, context: context)
//            Task(priority: .low) {
                let url = URL.init(string: "file:///Users/jon/src/kuluu/kuluu-ffxi-emulator/Sources/kuluu-ffxi-emulator/Zones/\(className).swift")
                try zoneCode.data(using: .utf8)?.write(to: url!)
                print("written")
//            }
        }
        let enumTemplate = """
        public enum Zone: Int {
            public static var current: Zone = Self.allCases.first!
            case ssandoria = 80
            case wronfaure = 100
            case valkurmDunes = 103
            //    case ssandoriaShadow = 230
            
            public var metadata: ZoneSceneMetadata {
                switch self {
                case .ssandoria: return SSandoria()
                case .wronfaure: return WRonfaure()
                case .valkurmDunes: return ValkurmDunes()
                }
            }
            
            public var spawnPoint: SIMD3<Float>? {
                metadata.lines.first?.position
            }
            
            public var nodeName: String {
                .init(rawValue)
            }
        }
        """
    }
}

//#if !SWIFT_PACKAGE
//private class TestBundleTarget { }
//#endif

func loadZoneDescriptorMap() async throws -> ZoneDescriptorMap {
    // swift can be fast if u use all da cores, watch this.
    // load all of the xml file urls in our resources
//    #if SWIFT_PACKAGE
    let bundle = Bundle.module
//    #else
//    let bundle = Bundle.init(for: TestBundleTarget.self)
//    #endif
    let urls = bundle.urls(forResourcesWithExtension: "xml", subdirectory: "Data")
    let zoneInfoUrl = bundle.url(forResource: "Data/ZoneINFO", withExtension: "json")!
    let zoneInfoJsonData = try Data(contentsOf: zoneInfoUrl, options: [])
    let jsonDecoder = JSONDecoder()
    print("ZoneINFO.json data length: ", zoneInfoJsonData.count)
    
    let zoneInfo: ZoneInfoContainer = try jsonDecoder.decode(ZoneInfoContainer.self, from: zoneInfoJsonData)
    
    let zones = zoneInfo.zoneInfo.sorted(by: { $0.id > $1.id })
    // pair urls with their data contents so we can process different urls differently if needed
    // (e.g. subregion vs. entities)
    let dataUrlTuples = try await urls?.concurrentCompactMap { url -> (Data, URL) in
        (try Data(contentsOf: url), url)
    }
    // grab entity XMLs (and discard subregions for now) concurrently
    enum DataType {
        case entity(Data), subregion(Data)
        
        init?(tuple: (Data, URL)) {
            let lastPath = tuple.1.lastPathComponent
            if lastPath.hasSuffix("_Entities.xml") {
                self = .entity(tuple.0)
            } else if lastPath.hasSuffix("_SubRegions.xml") {
                self = .subregion(tuple.0)
            } else {
                fatalError("unhandled xml file: \(lastPath)")
            }
        }
    }
    let dataTypes = await dataUrlTuples?.concurrentCompactMap(DataType.init(tuple:))
    // decode XML concurrently
    let zoneDescriptors = try await dataTypes?.concurrentCompactMap { dataType -> ZoneDescriptor? in
        switch dataType {
        case .subregion(let data):
            let zoneXML = try xmlDecoder.decode(ArrayOfSubRegion.self, from: data)
            let zoneMetadatas = zoneXML.zoneMetadatas
            return ZoneDescriptor(zoneInfo: nil, entity: nil, zoneMetadatas: zoneMetadatas)
        case .entity(let data):
            let zoneXML = try xmlDecoder.decode(ArrayOfEntity.self, from: data)
            let entities = zoneXML.entities
            return ZoneDescriptor(zoneInfo: nil, entity: entities, zoneMetadatas: nil)
        }
    }
    var zoneDescriptorMap: ZoneDescriptorMap = .init(minimumCapacity: zoneDescriptors?.count ?? 600)
    await zoneDescriptors?.asyncForEach { row in
        if let firstEntity = row.entity?.first {
            let zoneId = String(firstEntity.zoneId)
            let zoneInfo = zones[firstEntity.zoneId]
            if var zoneDescriptor = zoneDescriptorMap[zoneId] {
                zoneDescriptor.entity = row.entity!
                zoneDescriptorMap[zoneId] = zoneDescriptor
            } else {
                zoneDescriptorMap[zoneId] = .init(zoneInfo: zoneInfo, entity: row.entity!, zoneMetadatas: nil)
            }
        } else if let firstZoneMetadata = row.zoneMetadatas?.first {
            let zoneId = String(firstZoneMetadata.fileId)
            let zoneInfo = zones[firstZoneMetadata.fileId]
            if var zoneDescriptor = zoneDescriptorMap[zoneId] {
                zoneDescriptor.zoneMetadatas = row.zoneMetadatas!
                zoneDescriptorMap[zoneId] = zoneDescriptor
            } else {
                zoneDescriptorMap[zoneId] = .init(zoneInfo: zoneInfo, entity: nil, zoneMetadatas: row.zoneMetadatas!)
            }
        }
    }
    
    return zoneDescriptorMap
}
